#!/usr/bin/env node

import {web3, db, sql, acts, adresses, u} from './lib/common'
const abi = require('./abi/tub.json').abi
const tub = new web3.eth.Contract(abi, adresses.tub);

const options = {
  //fromBlock: web3.utils.toHex(process.env.FROM_BLOCK),
  //toBlock: web3.utils.toHex(process.env.TO_BLOCK)
  fromBlock: web3.utils.toHex(5003930),
  toBlock: web3.utils.toHex(5004930)
}

tub.getPastEvents('LogNote', Object.assign(options, {filter: {sig: acts.sigs}}))
.then(logs => {
  logs.forEach(log => {
    tub.methods.cups(log.returnValues.foo).call({}, log.blockNumber).then(cup => {
      let cupv = {
        lad: cup.lad,
        ink: u.wad(cup.ink),
        art: u.wad(cup.art),
        ire: u.wad(cup.irk),
        act: acts.acts[log.returnValues.sig],
        arg: u.wad('0x'+log.returnValues.bar.substring(26))
      }
      pgInsert(log, cupv)
    });
  });
});

tub.getPastEvents('LogNewCup', options).then(logs => {
  logs.forEach(log => {
    let cupv = {
      lad: log.returnValues.lad,
      ink: 0,
      art: 0,
      ire: 0,
      act: 'open',
      arg: null
    }
    pgInsert(log, cupv)
  });
});

async function pgInsert(log, cupv) {
  let cup = {
    id: web3.utils.hexToNumber(log.returnValues.foo),
    lad: cupv.lad,
    ink: cupv.ink,
    art: cupv.art,
    ire: cupv.ire,
    block: log.blockNumber,
    time: await u.timestamp(log.blockNumber),
    tx: log.transactionHash,
    act: acts.acts[log.returnValues.sig],
    arg: u.wad('0x'+log.returnValues.bar.substring(26))
  }
  db.none(sql.insert, {cup: cup}).then(() => {
    console.log(cup);
  });
}
